# -*- coding: utf-8 -*-
"""fastai-for-miniMIAS

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/0Bxi8S5NYOKRqaWN6U1M0bmZpNGVYQlhDY2I4bUZXZFFHQkpj
"""

!apt-get install -y -qq software-properties-common python-software-properties module-init-tools
!add-apt-repository -y ppa:alessandro-strada/ppa 2>&1 > /dev/null
!apt-get update -qq 2>&1 > /dev/null
!apt-get -y install -qq google-drive-ocamlfuse fuse
from google.colab import auth
auth.authenticate_user()
from oauth2client.client import GoogleCredentials
creds = GoogleCredentials.get_application_default()
import getpass
!google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret} < /dev/null 2>&1 | grep URL
vcode = getpass.getpass()
!echo {vcode} | google-drive-ocamlfuse -headless -id={creds.client_id} -secret={creds.client_secret}

# http://pytorch.org/
from os import path
from wheel.pep425tags import get_abbr_impl, get_impl_ver, get_abi_tag
platform = '{}{}-{}'.format(get_abbr_impl(), get_impl_ver(), get_abi_tag())

accelerator = 'cu80' if path.exists('/opt/bin/nvidia-smi') else 'cpu'

!pip install -q http://download.pytorch.org/whl/{accelerator}/torch-0.3.0.post4-{platform}-linux_x86_64.whl torchvision
import torch

print(torch.__version__)

!pip install fastai

!mkdir -p drive
!google-drive-ocamlfuse drive

# %reload_ext autoreload
# %autoreload 2
# %matplotlib inline

import cv2

from fastai.imports import *
import os

from fastai.transforms import *
from fastai.conv_learner import *
from fastai.model import *
from fastai.dataset import *
from fastai.sgdr import *
from fastai.plots import *

import sys
sys.path.insert(0, 'drive/ASHOKA forms/')
sys.path.insert(0, 'drive/ASHOKA forms/mias_labeled/')
#sys.path.insert(0, 'drive/ASHOKA forms/mias_binary_labeled/')
PATH = 'drive/ASHOKA forms/mias_labeled/'
#PATH = 'drive/ASHOKA forms/mias_binary_labeled/'
sz=224

torch.cuda.is_available()

torch.backends.cudnn.enabled

os.listdir(PATH)

os.listdir(f'{PATH}valid')

files = os.listdir(f'{PATH}valid/malign')
files

img = cv2.imread(f'{PATH}valid/malign/{files[1]}')
plt.imshow(img)

img.shape

aug1 = transforms_top_down = transforms_basic + [RandomDihedral()]
aug2 = transforms_side_on = transforms_basic + [RandomFlip()]

aug_types = [
    aug1,
    aug2,
]


aug_tfms = transforms_top_down = transforms_basic + [RandomDihedral()]
tfms = tfms_from_model(vgg16, sz, aug_tfms, max_zoom=1.1)     #=transforms_side_on

def get_augs():
    data = ImageClassifierData.from_paths(PATH, bs=2, tfms=tfms, num_workers=1)
    x,_ = next(iter(data.aug_dl))
    return data.trn_ds.denorm(x)[1]

arch = vgg16
data = ImageClassifierData.from_paths(PATH, tfms=tfms, num_workers=4)
learn = ConvLearner.pretrained(arch, data, precompute=True, ps=0.5)
learn.fit(0.1, 10)

lrf=learn.lr_find()

y = data.val_y

log_preds = learn.predict()
print(log_preds.shape)

log_preds = learn.predict()
log_preds.shape

log_preds[:10]

preds = np.argmax(log_preds, axis=1)  
probs = np.exp(log_preds[:,1])

def rand_by_mask(mask): return np.random.choice(np.where(mask)[0], 4, replace=False)
def rand_by_correct(is_correct): return rand_by_mask((preds == data.val_y)==is_correct)

def plot_val_with_title(idxs, title):
    imgs = np.stack([data.val_ds[x][0] for x in idxs])
    title_probs = [probs[x] for x in idxs]
    print(title)
    return plots(data.val_ds.denorm(imgs), rows=1, titles=title_probs)

def plots(ims, figsize=(12,6), rows=1, titles=None):
    f = plt.figure(figsize=figsize)
    for i in range(len(ims)):
        sp = f.add_subplot(rows, len(ims)//rows, i+1)
        sp.axis('Off')
        if titles is not None: sp.set_title(titles[i], fontsize=16)
        plt.imshow(ims[i])

def load_img_id(ds, idx): return cv2.imread(PATH+ds.fnames[idx])

def plot_val_with_title(idxs, title):
    imgs = [load_img_id(data.val_ds,x) for x in idxs]
    title_probs = [probs[x] for x in idxs]
    print(title)
    return plots(imgs, rows=1, titles=title_probs, figsize=(16,8))

plot_val_with_title(rand_by_correct(True), "Correctly classified")

plot_val_with_title(rand_by_correct(False), "Incorrectly classified")

def most_by_mask(mask, mult):
    idxs = np.where(mask)[0]
    return idxs[np.argsort(mult * probs[idxs])[:4]]

def most_by_correct(y, is_correct): 
    mult = -1 if (y==1)==is_correct else 1
    return most_by_mask(((preds == data.val_y)==is_correct) & (data.val_y == y), mult)

plot_val_with_title(most_by_correct(0, True), "Most correct malignant mammograms")

plot_val_with_title(most_by_correct(1, True), "Most correct benign mammograms")

plot_val_with_title(most_by_correct(0, False), "Most incorrect malignant mammograms")

plot_val_with_title(most_by_correct(1, False), "Most incorrect benign mammograms")

most_uncertain = np.argsort(np.abs(probs -0.5))[:4]
plot_val_with_title(most_uncertain, "Most uncertain predictions")

learn.sched.plot_lr()

learn.sched.plot()

#ims = np.stack([get_augs() for i in range(2)])

plots(ims, rows=2)

preds = np.argmax(log_preds , axis=1)  # from log probabilities to 0 or 1
probs = np.exp(log_preds[:,1])

from sklearn.metrics import confusion_matrix
cm = confusion_matrix(y, preds)

plot_confusion_matrix(cm, data.classes)

sum(np.diag(cm)) / 49   #Calculating acc

